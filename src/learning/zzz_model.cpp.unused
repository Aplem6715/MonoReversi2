#include "model.h"
#include "bit_operation.h"
#include "../ai/ai_const.h"
#include <vector>
#include <stdlib.h>
#include <chrono>

using namespace std;
using namespace tiny_dnn::layers;
using namespace tiny_dnn::activation;

void MakeInput(vec_t &input, const uint16 features[])
{
    int idxShift = 0;
    for (int i = 0; i < FEAT_NUM; i++)
    {
        input[idxShift + features[i]] = 1.0;
        idxShift += FeatMaxIndex[i];
    }
}

ValueModel::ValueModel()
{
    for (int i = 0; i < NB_PHASE; i++)
    {
        network<sequential> net;
        net << fc(FEAT_NB_COMBINATION, VALUE_HIDDEN_UNITS1, false) << relu()
            << fc(VALUE_HIDDEN_UNITS1, VALUE_HIDDEN_UNITS2) << relu()
            << fc(VALUE_HIDDEN_UNITS2, 1) << linear(1);

        // Weightを0初期化
        net.weight_init(weight_init::constant(0));

        this->nets.push_back(net);
        cout << "MLP Net phase" << i << " initialized!\n";
    }

    std::ofstream ofs("graph_net_example.txt");
    graph_visualizer viz(this->nets[0], "graph");
    viz.generate(ofs);
};

float ValueModel::predict(uint16 features[], uint8 nbEmpty)
{
    // 3 x 8 x 8
    static vector<vec_t> inputs(1, vec_t(FEAT_NB_COMBINATION));
    static float output;

    int idxShift = 0;

    MakeInput(inputs[0], features);

    /*DEBUG
    for (int i = 0; i < FEAT_NUM; i++)
    {
        uint32 idx = 0;
        for (idx = 0; idx < FeatMaxIndex[i]; idx++)
        {
            if (inputs[0][idxShift + idx] > 0)
            {
                printf("%d, ", idx);
                break;
            }
        }
        idxShift += FeatMaxIndex[i];
    } DEBUG*/

    output = nets[PHASE(nbEmpty)].predict(inputs)[0][0];
    return output;
}

void ValueModel::train(const std::vector<GameRecord> &gameRecords)
{
    adam opt;
    vector<tensor_t> input(NB_PHASE);
    vector<tensor_t> desiredOut(NB_PHASE);
    chrono::system_clock::time_point start, end;

    size_t batchSize = 32;
    int epochs = 3;

    for (int i = 0; i < gameRecords.size(); i++)
    {
        int phase = PHASE(gameRecords[i].nbEmpty);

        vec_t featStats(FEAT_NB_COMBINATION);
        MakeInput(featStats, gameRecords[i].featStats);
        input[phase].push_back(featStats);

        vec_t outTmp(1);
        outTmp[0] = gameRecords[i].resultForBlack;
        desiredOut[phase].push_back(outTmp);
    }

    /*DEBUG
    for (int phase = 0; phase < NB_PHASE; phase++)
    {
        for (int i = 0; i < input[phase].size(); i++)
        {
            float sum = 0;
            for (int j = 0; j < input[phase][i].size(); j++)
            {
                sum += input[phase][i][j];
            }
            if (sum != FEAT_NUM)
            {
                cerr << "不正な入力Tensor\n";
                assert(0);
            }
            else
            {
                sum = 0;
            }
        }
    }
    DEBUG*/

    for (int phase = 0; phase < NB_PHASE; phase++)
    {
        int epoch = 0;
        start = chrono::system_clock::now();
        nets[phase].fit<mse>(
            opt, input[phase], desiredOut[phase], batchSize, epochs, []() {},
            [&]() {
                cout << "learning epoch: " << epoch << '\r';
                epoch++;
            });
        end = chrono::system_clock::now();
        double elapsed = (double)chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        cout << "phase" << phase
             << "  loss: " << nets[phase].get_loss<mse>(input[phase], desiredOut[phase]) / input[phase].size()
             << "  time: " << elapsed / 1000 << "[s]"
             << '\n';
    }
}

void ValueModel::Save(string saveDir)
{
    for (int phase = 0; phase < NB_PHASE; phase++)
    {
        nets[phase].save(saveDir + "phase" + to_string(phase));
    }
}

void ValueModel::Load(string loadDir)
{
    for (int phase = 0; phase < NB_PHASE; phase++)
    {
        nets[phase].load(loadDir + "phase" + to_string(phase));
    }
}


void ConvertWeights(vector<vec_t *> layerW, Weights *weights)
{
    vec_t *weight = layerW[0];
    vec_t *bias = NULL;
    size_t nbConnects = weight->size();

    if (layerW.size() == 2)
    {
        bias = layerW[1];
    }

    if (weights->nbConnect != weight->size())
    {
        if (weights->bias != NULL)
        {
            free(weights->bias);
        }
        if (weights->weights != NULL)
        {
            free(weights->weights);
        }
        if (bias)
        {
            weights->bias = (float *)malloc(sizeof(Weights) * nbConnects);
        }
        weights->weights = (float *)malloc(sizeof(Weights) * nbConnects);
        weights->nbConnect = nbConnects;
    }

    for (size_t i = 0; i < nbConnects; i++)
    {
        weights->weights[i] = (*weight)[i];
        if (bias)
        {
            weights->bias[i] = (*bias)[i];
        }
    }
}

void ValueModel::CopyWeightsTo(Weights weights[NB_PHASE][NB_LAYERS])
{
    for (int phase = 0; phase < NB_PHASE; phase++)
    {
        for (int layer = 0; layer < 3; layer++)
        {
            vector<vec_t *> layerW = nets[phase][layer * 2]->weights();
            ConvertWeights(layerW, &weights[phase][layer]);
        }
    }
}
