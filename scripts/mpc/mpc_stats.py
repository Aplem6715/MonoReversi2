import subprocess
import pickle
import os
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
from typing import List


MPC_SHALLOW_MIN = 1
MPC_SHALLOW_MAX = 6
MPC_DEEP_MIN = 3
MPC_DEEP_MAX = 16
MPC_NB_TRY = 2

NB_PLAYOUT = 150
MATCH_IDX_SHIFT = 10000

use_plt = False

mpc_stats_pkl_file = "./resources/mpc/mpc_stats.pkl"
raw_csv_file = "./resources/mpc/mpc_raw_tmp.csv"
target_c_file = "./src/search/mpc_info.cpp"
mpc_playout_exe = "./build/release/learn/mpc_playout.exe"

dummy_data_str = "\t{\n" + \
    ("\t\t{{0, -1, -1, -1}, {0, -1, -1, -1}},\n"
     * (MPC_DEEP_MAX - MPC_DEEP_MIN + 1)) + \
    "\t},\n"

pair_list = [
    [(3, 1)],
    [(4, 2)],
    [(5, 1)],
    [(6, 2)],
    [(7, 3)],
    [(8, 4)],
    [(9, 3), (9, 5)],
    [(10, 4), (10, 6)],
    [(11, 3), (11, 5)],
    [(12, 6)],
    [(13, 5)],
    [(14, 6)],
    [(15, 5)],
    [(16, 6)]
]


class MPCPair:
    def __init__(self):
        self.shallow = 0
        self.slope = -1.0
        self.bias = -1.0
        self.std = -1.0


def calc_score_pair(score_df, pair):
    deep = pair[0]
    shallow = pair[1]
    score_list = []

    matchIdxList = score_df["matchIdx"].unique()
    for match in matchIdxList:

        match_df = score_df[score_df["matchIdx"] == match]

        d_score = match_df[match_df["depth"]
                           == deep]["score"]
        s_score = match_df[match_df["depth"]
                           == shallow]["score"]

        if len(d_score) > 0 and len(s_score) > 0:
            score_list.append(
                [s_score.values[0], d_score.values[0]]
            )

    return score_list


def learn_model(x, y):
    model = LinearRegression()
    model.fit(x, y)
    return model


def get_stats_list(df, mpc_pair: MPCPair, pair):
    score_list = calc_score_pair(df, pair)

    score_array = np.array(score_list)  # type: np.ndarray
    if(len(score_array) <= 0):
        return
    x = score_array[:, 0].reshape(-1, 1)
    y = score_array[:, 1].reshape(-1, 1)

    model = learn_model(x, y)
    preds = model.predict(x)

    if use_plt:
        plt.title(
            f'shallow:{pair[1]} '
            f'deep:{pair[0]} '
            f'a:{model.coef_[0][0]:.3f} b:{model.intercept_[0]:.3f}')
        plt.plot(x, y, 'o')
        plt.plot(x, preds)
        plt.show()

    diff = y - preds

    mpc_pair.shallow = pair[1]
    mpc_pair.slope = model.coef_[0][0]
    mpc_pair.bias = model.intercept_[0]
    mpc_pair.std = diff.std()

    print(mpc_pair.std)

    if use_plt:
        plt.hist(diff, bins=25)
        plt.show()


def write_mpc_stats(mpc_stats: List[List[List[MPCPair]]], outfile):
    with open(outfile, mode='w') as f:
        f.write(
            '\n/* Auto Generated by Python Script: mpc_stats.py */\n\n'
            '#include "mpc.h"\n\n'
            "extern const MPCPair"
            " mpcPairs[60][MPC_DEEP_MAX - MPC_DEEP_MIN + 1][MPC_NB_TRY] = {\n")
        for nb_empty in range(60):
            if(not mpc_stats[nb_empty]):
                f.write(dummy_data_str)
                continue
            f.write(f"\t{{ /* nbEmpty:{nb_empty} */\n")
            for depth in range(MPC_DEEP_MAX-MPC_DEEP_MIN+1):
                f.write(f"\t\t/* {depth+MPC_DEEP_MIN:2} */ {{")
                for tries in range(2):
                    mpc_stat = mpc_stats[nb_empty][depth][tries]
                    f.write(
                        f"{{{mpc_stat.shallow}, {mpc_stat.slope:.6f}"
                        f", {mpc_stat.bias:.6f}, {mpc_stat.std:.6f}}},")
                f.write("},\n")
            f.write("\t},\n")
        f.write("};\n")


def read_mpc_games(pair, pair_i):
    raw_df = pd.read_csv(raw_csv_file, sep=',')
    nb_empty_min = 10
    nb_empty_max = raw_df['nbEmpty'].max()+1

    mpc_stats = None
    if os.path.exists(mpc_stats_pkl_file):
        mpc_stats = pickle.load(open(mpc_stats_pkl_file, "rb"))

    if not mpc_stats:
        mpc_stats = [
            [
                [
                    MPCPair() for i in range(MPC_NB_TRY)
                ]for i in range(MPC_DEEP_MAX - MPC_DEEP_MIN + 1)
            ] for i in range(60)
        ]

    for nb_empty in range(nb_empty_min, nb_empty_max):
        print("caluclating empty: "+str(nb_empty))
        scores_df = raw_df[raw_df['nbEmpty'] == nb_empty]
        get_stats_list(
            scores_df,
            mpc_stats[nb_empty][pair[0] - MPC_DEEP_MIN][pair_i],
            pair
        )

    pickle.dump(mpc_stats, open(mpc_stats_pkl_file, "wb"))
    write_mpc_stats(mpc_stats, target_c_file)


def compile():
    subprocess.run(("nmake", "-frelease_mpc.mk"))


def playout(pair, matchIdx):
    subprocess.run((mpc_playout_exe,
                    str(NB_PLAYOUT),
                    str(matchIdx),
                    str(pair[1]),
                    str(pair[0]),
                    "0"))


def main():
    matchIdx = MATCH_IDX_SHIFT

    # pickleデータをリセット
    pickle.dump(None, open(mpc_stats_pkl_file, "wb"))

    # 空のダミーデータを記録
    write_mpc_stats([None] * 60, target_c_file)

    for pairs in pair_list:
        pair_i = 0
        for pair in pairs:
            # ゲームデータをリセット
            with open(raw_csv_file, "w") as f:
                print("overwrite raw data")
                f.write("matchIdx,nbEmpty,depth,score\n")

            # コンパイルしてMPC情報を適用
            compile()
            playout(pair, matchIdx)
            read_mpc_games(pair, pair_i)

            matchIdx += MATCH_IDX_SHIFT
            pair_i += 1


if __name__ == '__main__':
    main()
